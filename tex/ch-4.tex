\section{Програмне та техніче забезпечення}
\subsection{Засоби розробки}

Платформи:
Цільовими платформами системи ``Memspacer'' є PC та Android. Такий вибір обумовлено великою популярністю цих платформ, і покриття ними досить великих сегментів десктопного та мобільного секторів.

Операційні системи:
Цільовими операційними системами є Windows і Linux, та можливо подальше портування на MacOS.
Стек технологій вибрано чином, відносно полегчуючим подальше розширення підтримки продукту іншими платформами та операційними системами.

Мова програмування:
У якості мови програмування обрано С++. Такий вибір обумовлено контролем над моделю памяті, що ця мова надає програмісту, і, як наслідок, можливістю реалізації спеціалізованих під потреби системи, підсистем схем ефективного її менеджменту (наприклад, використання пулів памяті для частостворюваних короткоживучих об'єктів для запобігнення фрагментації пам'яті та зменшення затрат на алокації, тощо), а також наявністю відполірованих роками бібліотек, необхідних для ефективного вирішення задач, які виникли у даній системі.

Бібліотеки:
У якості графічної бібліотеки обрано OpenGL (Open Graphical Library) за її кросплатформенність та прогресивність.
Для інтеграції графічного контексту з вікнами операційних систем та пристроями вводу-виводу використовується бібліотека GLFW.
Для математичних операцій обрано бібліотеку GLM (OpenGL Mathemathics).

База даних:
У якості бази даних обрано NoSQL рішення типу key-value storage під назвою Redis. Такий вибір обумовлено невеликою складністю даних, та ефективністю даної системи у роботі з такими даними.

\subsection{Вимоги до технічного забезпечення}

Для правильної роботи даної програми до складу технічних засобів повинні входити:

\begin{enumerate}
  \item Персональний комп'ютер чи пристрій під управлінням Android, задовольняючий наступним характеристикам:
  \begin{itemize}
    \item процесор з тактовою частотою не нижче 400 Ггц;
    \item достатній об'єм оперативної памяті (не менше 64 МБ);
    \item наявність графічного процесору, задовольняючого наступним вимогам:
    \begin{itemize}
      \item об'єм відеопам'яті не менше ніж 32 МБ;
      \item підтримка OpenGL ES як мінімум версії 2.0;
    \end{itemize}
  \end{itemize}
  \item Додатково на комп'ютері чи пристрої повинна бути доступною динамічна бібліотека трьовимірної графіки OpenGL;
  \item Периферія, до складу якої входить:
  \begin{itemize}
    \item дисплей;
    \item кнопки (клавітура, тачскрин, чи кнопки пристрою);
    \item пристрій для відтворення звуку;
  \end{itemize}
\end{enumerate}

\subsection{Архітектура програмного забезпечення}

\subsubsection{Діаграми класів}

Ігровими об'єктами у системі ``Memspacer'' є дошка (Cube), її клітини (Cell), та сцена (StarNest). Вони відображені у нижченаведеній ієрархії:

\begin{center}
  \includegraphics[scale=0.6]{./cd-gameobjects.jpg}
\end{center}

Ефектом є довільний вплив на стан об'єкту, який відбувається впродовж деякого проміжку часу. Коренем іерархії ефектів є Effect<Target>, де Target — це тип об'єкту, на стан якого відбувається вплив.
Для комбінування ефектів відведені спеціальні класи:
Parallel<Target> комбінує два ефекти у новий ефект, в якому впливи двух довільних ефектів над Target відбуваються параллельно;
Sequential<Target> комбінує два ефекти у новий ланцюжковий ефект, в якому дія другого починається після закінчення проміжку впливу першого.
	Для зручної композиції ефектів вищеописаними комбінаторами реалізовано невеличкий eDSL (Embedded Domain Specific Language), відображений у ієрархії EffectTerm.

\begin{center}
  \includegraphics[scale=0.6]{./cd-effects.jpg}
\end{center}

Для спрощення менеджменту шейдерів, вони структуровані нижченаведеною ієрархією класів:

\begin{center}
  \includegraphics[scale=0.6]{./cd-shaders.jpg}
\end{center}

Ініціалізація графічного контексту, вікон, обробка вводу-виводу, та головний цикл гри відбуваються у класі Game. Глобальні параметри рендерингу, які є основним контекстом рендерингу, захоплені у класі Renderer:

\begin{center}
  \includegraphics[scale=0.6]{./cd-misc.jpg}
\end{center}

\subsubsection{Специфікація функцій}

\small{
  \begin{tabular}{| C{6cm} | C{4cm} | C{5cm} |}
    \hline
    Ідентифікатор & Тип & Опис \\
    \hline
    ``core/configuration.hpp'' \newline core:: \newline parse_configuration
    & vector<string> $\to$ Configuration
    & Формує об'єкт конфігурації із вектору параметрів командної строки \\
    \hline
    ``core/effect.hpp'' \newline core:: \newline Effect<T>::free \newline (pool)
    & Pool\& $\to$ void
    & Звільняє пам'ять, відведену під даний ефект у даному пулі \emph{pool} \\
    \hline
    ``core/effect.hpp'' \newline core:: \newline Effect<T>::process \newline (target, delta)
    & (T\&, float) $\to$ bool
    & Застосовує дію даного ефекту на проміжку часу \emph{delta} до цілі \emph{target} \\
    \hline
    ``core/game_object.hpp'' \newline core:: \newline
    GameObject::update \newline (delta, pool)
    & (float, Pool\&) $\to$ void
    & Моделює розвиток стану об'єкту на проміжку часу \emph{delta} із пулом ефектів \emph{pool} \\
    \hline
    ``core/game_object.hpp'' \newline core:: \newline
    GameObject::render \newline (render_ctx)
    & RenderContext\& $\to$ void
    & Виконує дії з графічного відображення даного об'єкту на екран
      за заданого контексту рендерінгу \emph{render_ctx} \\
    \hline
    ``core/game_object.hpp'' \newline core:: \newline
    GameObjectTemplate<Self>:: \newline update \newline (delta, pool)
    & (float, Pool\&) $\to$ void
    & Стандартна реалізація \emph{GameObject::render}, що поновлює із заданими параметрами усі ефекти, застосовані до даного ігрового об'єкту \\
    \hline
    ``core/game_object.hpp'' \newline core:: \newline
    GameObjectTemplate<Self>:: \newline attach_effect \newline (effect)
    & Effect<Self>\& $\to$ void
    & Застосовує заданий ефект до даного ігрового об'єкту, та вносить його у список ефектів цього об'єкту \\
    \hline
    ``core/shader.hpp'' \newline core:: \newline
    Shader::load \newline (shader_type, file_path)
    & (GLenum, string) $\to$ GLuint
    & Завантажує шейдер заданого типу \emph{shader_type} із файлу, розташованого за шляхом \emph{file_path}, і повертає його ідентифікатор \\
    \hline
  \end{tabular}
% GLuint load(GLenum shader_type, std::string file_path)
}