\section{Програмне та техніче забезпечення}
\subsection{Засоби розробки}

Платформи:
Цільовими платформами системи ``Memspacer'' є PC та Android. Такий вибір обумовлено великою популярністю цих платформ, і покриття ними досить великих сегментів десктопного та мобільного секторів.

Операційні системи:
Цільовими операційними системами є Windows і Linux, та можливо подальше портування на MacOS.
Стек технологій вибрано чином, відносно полегчуючим подальше розширення підтримки продукту іншими платформами та операційними системами.

Мова програмування:
У якості мови програмування обрано С++. Такий вибір обумовлено контролем над моделю памяті, що ця мова надає програмісту, і, як наслідок, можливістю реалізації спеціалізованих під потреби системи, підсистем схем ефективного її менеджменту (наприклад, використання пулів памяті для частостворюваних короткоживучих об'єктів для запобігнення фрагментації пам'яті та зменшення затрат на алокації, тощо), а також наявністю відполірованих роками бібліотек, необхідних для ефективного вирішення задач, які виникли у даній системі.

Бібліотеки:
У якості графічної бібліотеки обрано OpenGL (Open Graphical Library) за її кросплатформенність та прогресивність.
Для інтеграції графічного контексту з вікнами операційних систем та пристроями вводу-виводу використовується бібліотека GLFW.
Для математичних операцій обрано бібліотеку GLM (OpenGL Mathemathics).

База даних:
У якості бази даних обрано NoSQL рішення типу key-value storage під назвою Redis. Такий вибір обумовлено невеликою складністю даних, та ефективністю даної системи у роботі з такими даними.

\subsection{Вимоги до технічного забезпечення}

Для правильної роботи даної програми до складу технічних засобів повинні входити:

\begin{enumerate}
  \item Персональний комп'ютер чи пристрій під управлінням Android, задовольняючий наступним характеристикам:
  \begin{itemize}
    \item процесор з тактовою частотою не нижче 400 Ггц;
    \item достатній об'єм оперативної памяті (не менше 64 МБ);
    \item наявність графічного процесору, задовольняючого наступним вимогам:
    \begin{itemize}
      \item об'єм відеопам'яті не менше ніж 32 МБ;
      \item підтримка OpenGL ES як мінімум версії 2.0;
    \end{itemize}
  \end{itemize}
  \item Додатково на комп'ютері чи пристрої повинна бути доступною динамічна бібліотека трьовимірної графіки OpenGL;
  \item Периферія, до складу якої входить:
  \begin{itemize}
    \item дисплей;
    \item кнопки (клавітура, тачскрин, чи кнопки пристрою);
    \item пристрій для відтворення звуку;
  \end{itemize}
\end{enumerate}

\subsection{Архітектура програмного забезпечення}

\subsubsection{Діаграми класів}

Ігровими об'єктами у системі ``Memspacer'' є дошка (Cube), її клітини (Cell), та сцена (StarNest). Вони відображені у нижченаведеній ієрархії:

\begin{center}
  \includegraphics[scale=0.6]{./cd-gameobjects.jpg}
\end{center}

Ефектом є довільний вплив на стан об'єкту, який відбувається впродовж деякого проміжку часу. Коренем іерархії ефектів є Effect<Target>, де Target — це тип об'єкту, на стан якого відбувається вплив.
Для комбінування ефектів відведені спеціальні класи:
Parallel<Target> комбінує два ефекти у новий ефект, в якому впливи двух довільних ефектів над Target відбуваються параллельно;
Sequential<Target> комбінує два ефекти у новий ланцюжковий ефект, в якому дія другого починається після закінчення проміжку впливу першого.
	Для зручної композиції ефектів вищеописаними комбінаторами реалізовано невеличкий eDSL (Embedded Domain Specific Language), відображений у ієрархії EffectTerm.

\begin{center}
  \includegraphics[scale=0.6]{./cd-effects.jpg}
\end{center}

Для спрощення менеджменту шейдерів, вони структуровані нижченаведеною ієрархією класів:

\begin{center}
  \includegraphics[scale=0.6]{./cd-shaders.jpg}
\end{center}

Ініціалізація графічного контексту, вікон, обробка вводу-виводу, та головний цикл гри відбуваються у класі Game. Глобальні параметри рендерингу, які є основним контекстом рендерингу, захоплені у класі Renderer:

\begin{center}
  \includegraphics[scale=0.6]{./cd-misc.jpg}
\end{center}

\subsubsection{Специфікація функцій}

\small{
  \begin{longtable}{| C{6cm} | C{4cm} | C{5cm} |}
    \hline
    Ідентифікатор & Тип & Опис \\

    %%%%%% core/...
    \hline
    ``core/configuration.hpp'' \newline core:: \newline parse_configuration \newline (args)
    & vector<string> $\to$ Configuration
    & Формує об'єкт конфігурації із вектору параметрів командної строки \emph{args} \\
    \hline
    ``core/effect.hpp'' \newline core:: \newline Effect<T>::free \newline (pool)
    & Pool\& $\to$ void
    & Звільняє пам'ять, відведену під даний ефект у даному пулі \emph{pool} \\
    \hline
    ``core/effect.hpp'' \newline core:: \newline Effect<T>::process \newline (target, delta)
    & (T\&, float) $\to$ bool
    & Застосовує дію даного ефекту на проміжку часу \emph{delta}
    до цілі \emph{target} та повертає логічне значення, що показує,
    чи завершився час дії ефекту після даної ітерації моделювання \\
    \hline
    ``core/render_context.hpp'' \newline core:: \newline
    RenderContext::new \newline (view, proj)
    & (const Mat4\&, const Mat4\&) $\to$ RenderContext
    & Конструює контекст рендерінгу з заданими початковими
    матрицями виду \emph{view} і проекції \emph{proj} \\

    %%%%%% core/game_object
    \hline
    ``core/game_object.hpp'' \newline core:: \newline
    GameObject::update \newline (delta, pool)
    & (float, Pool\&) $\to$ void
    & Моделює розвиток стану об'єкту на проміжку часу
    \emph{delta} із пулом ефектів \emph{pool} \\
    \hline
    ``core/game_object.hpp'' \newline core:: \newline
    GameObject::render \newline (render_ctx)
    & RenderContext\& $\to$ void
    & Виконує дії з графічного відображення даного об'єкту на екран
      за заданого контексту рендерінгу \emph{render_ctx} \\
    \hline
    ``core/game_object.hpp'' \newline core:: \newline
    GameObjectTemplate<Self>:: \newline update \newline (delta, pool)
    & (float, Pool\&) $\to$ void
    & Стандартна реалізація \emph{GameObject::render},
    що поновлює із заданими параметрами усі ефекти,
    застосовані до даного ігрового об'єкту \\
    \hline
    ``core/game_object.hpp'' \newline core:: \newline
    GameObjectTemplate<Self>:: \newline attach_effect \newline (effect)
    & Effect<Self>\& $\to$ void
    & Застосовує заданий ефект до даного ігрового об'єкту,
    та вносить його у список ефектів цього об'єкту \\

    %%%%%% core/shader
    \hline
    ``core/shader.hpp'' \newline core:: \newline
    Shader::load \newline (shader_type, file_path)
    & (GLenum, string) $\to$ GLuint
    & Завантажує шейдер заданого типу \emph{shader_type} із файлу,
    розташованого за шляхом \emph{file_path}, і повертає його ідентифікатор \\
    \hline
    ``core/shader.hpp'' \newline core:: \newline
    Shader::use
    & void
    & Встановлює даний шейдер частиною поточного стану рендерінгу \\
    \hline
    ``core/shader.hpp'' \newline core:: \newline
    Shader::new \newline (descriptions)
    & initializer_list \newline <(GLenum,string)> \newline $\to$ Shader
    & Конструює шейдерну програму із набору пар-описів, кожна з яких
    складається з типу шейдеру та шляху до його файлу \\

    %%%%%% effect/parallel
    \hline
    ``effect/parallel.hpp'' \newline effect:: \newline
    Parallel<T>::new \newline (first, second)
    & (Effect<T>\&, Effect<T>\&) $\to$ Effect
    & Паралельна композиція ефектів \emph{first} та \emph{second} \\
    \hline
    ``effect/parallel.hpp'' \newline effect:: \newline
    Parallel<T>::free \newline (pool)
    & Pool\& $\to$ void
    & Звільняє пам'ять, відведену під даний ефект, та його складові ефекти, у даному пулі \\
    \hline
    ``effect/parallel.hpp'' \newline effect:: \newline Parallel<T>::process \newline (target, delta)
    & (T\&, float) $\to$ bool
    & Застосовує дію даної композиції ефектів на проміжку часу \emph{delta}
    до цілі \emph{target} та повертає логічне значення, що показує,
    чи завершився час дії ефектів після даної ітерації моделювання \\

    %%%%%% effect/sequential
    \hline
    ``effect/sequential.hpp'' \newline effect:: \newline
    Sequential<T>::new \newline (first, second)
    & (Effect<T>\&, Effect<T>\&) $\to$ Effect
    & Послідовна композиція ефектів \emph{first} та \emph{second} \\
    \hline
    ``effect/sequential.hpp'' \newline effect:: \newline
    Sequential<T>::free \newline (pool)
    & Pool\& $\to$ void
    & Звільняє пам'ять, відведену під даний ефект, та його складові ефекти, у даному пулі \\
    \hline
    ``effect/sequential.hpp'' \newline effect:: \newline Sequential<T>::process \newline (target, delta)
    & (T\&, float) $\to$ bool
    & Застосовує дію даної композиції ефектів на проміжку часу \emph{delta}
    до цілі \emph{target} та повертає логічне значення, що показує,
    чи завершився час дії ефектів після даної ітерації моделювання \\

    %%%%%% effect/algebra
    \hline
    ``effect/algebra.hpp'' \newline effect:: \newline EffectTerm<Self>:: \newline
    (||)<ET> \newline (other)
    & ET $\to$ \newline ParEffectTerm \newline <Self, ET>
    & Комбінатор термів паралельної композиції ефектів \\
    \hline
    ``effect/algebra.hpp'' \newline effect:: \newline EffectTerm<Self>:: \newline
    (>>)<ET> \newline (other)
    & ET $\to$ \newline SeqEffectTerm \newline <Self, ET>
    & Комбінатор термів послідовної композиції ефектів \\
    \hline
    ``effect/algebra.hpp'' \newline effect:: \newline WrapEffectTerm<T>:: \newline
    eval \newline (pool)
    & Pool\& $\to$ Effect<T>*
    & Інтерпретує врапаючі терми підмови опису ефектів з заданим пулом \\
    \hline
    ``effect/algebra.hpp'' \newline effect:: \newline ParEffectTerm<ET1,ET2>:: \newline
    eval \newline (pool)
    & Pool\& $\to$ Effect<T>*
    & Інтерпретує паралельно-композиційні терми підмови опису ефектів з заданим пулом \\
    \hline
    ``effect/algebra.hpp'' \newline effect:: \newline SeqEffectTerm<ET1,ET2>:: \newline
    eval \newline (pool)
    & Pool\& $\to$ Effect<T>*
    & Інтерпретує послідовно-композиційні терми підмови опису ефектів з заданим пулом \\

    %%%%%% effects/rotation
    \hline
    ``effects/rotation.hpp'' \newline effects:: \newline Rotation<Oriented>:: \newline
    new \newline (duration, orientation)
    & (float, Quat) $\to$ Rotation<Oriented>
    & Конструює ефект обертання з заданою тривалістю \emph{duration}
    та кватерніоном оберту \emph{orientation} \\
    \hline
    ``effects/rotation.hpp'' \newline effects:: \newline Rotation<Oriented>:: \newline
    process \newline (target, delta)
    & (Oriented\&, float) $\to$ bool
    & Застосовує описуєме даним об'єктом обертання на проміжку часу \emph{delta}
    до цілі \emph{target} та повертає логічне значення, що показує,
    чи завершився час дії ефекту після даної ітерації моделювання \\

    %%%%%% effects/blink
    \hline
    ``effects/blink.hpp'' \newline effects:: \newline Blink<Colored>:: \newline
    new \newline (duration, color)
    & (float, Vec4) $\to$ Rotation<Oriented>
    & Конструює ефект блимання з заданою тривалістю \emph{duration} та кольором \emph{color} \\
    \hline
    ``effects/blink.hpp'' \newline effects:: \newline Blink<Colored>:: \newline
    process \newline (target, delta)
    & (Colored\&, float) $\to$ bool
    & Застосовує описуєме даним об'єктом блимання на проміжку часу \emph{delta}
    до цілі \emph{target} та повертає логічне значення, що показує,
    чи завершився час дії ефекту після даної ітерації моделювання \\

    %%%%%% game_objects/cell
    \hline
    ``game_objects/cell.hpp'' \newline game_objects:: \newline Cell<Owner>:: \newline
    new \newline (parent, position, orientation, color)
    & (Owner*, Vec3, Quat, Vec4) $\to$ Cell<Owner>
    & Конструює клітину дошки із заданими дошкою \emph{parent},
    розташуванням \emph{position},  орієнтацією \emph{orientation},
    та кольором \emph{color} \\
    \hline
    ``game_objects/cell.hpp'' \newline game_objects:: \newline Cell<Owner>:: \newline
    render \newline (render_ctx)
    & const RenderContext\& $\to$ void
    & Виконує дії з графічного відображення даного об'єкту на екран
      за заданого контексту рендерінгу \emph{render_ctx} \\

    \hline
  \end{longtable}
}